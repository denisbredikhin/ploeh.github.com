---
layout: post
title: "Song recommendations with free monads"
description: "A Golden Hammer."
date: 2025-08-11 6:04 UTC
tags: [Functional Programming]
---
{% include JB/setup %}

<div id="post">
    <p>
        <em>{{ page.description }}</em>
    </p>
    <p>
        This article is part of a larger article series about <a href="/2025/04/07/alternative-ways-to-design-with-functional-programming">alternative ways to design with functional programming</a>, particularly when faced with massive data loads. In previous articles in the series, you've seen various alternatives that may or may not enable you to solve the example problem using functional programming. Each of the previous alternatives, <a href="/2025/04/28/song-recommendations-as-an-impureim-sandwich">applying the Recawr Sandwich pattern</a>, <a href="/2025/06/09/song-recommendations-from-combinators">employing functional combinators</a>, or <a href="/2025/07/14/song-recommendations-with-pipes-and-filters">using pipes and filters</a>, came with some trade-offs. Either there were limits to the practicality of the architecture, or it wasn't really functional after all.
    </p>
    <p>
        In this, and the following three articles, we finally reach for a universal solution: Free monads.
    </p>
    <p>
        By <em>universal</em> I mean: It's always possible to do this (if your language supports it). It doesn't follow that it's always a good idea.
    </p>
    <p>
        So there are trade-offs here, too.
    </p>
    <p>
        As is usually the case, although sometimes I forget to write it, this and the following articles are <em>descriptive</em>, not prescriptive. In no way do I insist that things must be done this way. I only present examples as options.
    </p>
    <h3 id="137ca70378114954a7905e93ba8c21a8">
        The last resort <a href="#137ca70378114954a7905e93ba8c21a8">#</a>
    </h3>
    <p>
        If using a free monad is a universal possibility, then why is that not the default option? Why have I waited this long in the article series before covering it?
    </p>
    <p>
        For more than a single reason.
    </p>
    <p>
        It's an 'advanced' technique, and I predict that to many programmers, it looks like black magic. If you're working with a team unready for free monads, foisting it upon them are unlikely to lead to anything good.
    </p>
    <p>
        The following story may illustrate the problem. It's not about free monads, but rather about Dependency Injection (DI) Containers. A specific one, actually. I was consulting with a team, working as a temporary lead developer for about half a year. I made a number of technical decisions, some of them good and others not so much. Among the latter was the decision to use the <a href="https://www.castleproject.org/projects/windsor/">Castle Windsor</a> DI Container.
    </p>
    <p>
        Not that Castle Windsor was a bad library. After having done the research and written <a href="/ref/diidn">a book</a>, I considered it the best DI Container available.
    </p>
    <p>
        The problem, rather, was that the rest of the team considered it 'automagical'. Not that they weren't sophisticated programmers, but they had no interest learning the Castle Windsor API. They didn't consider it part of their core work, and they didn't think it provided enough benefit compared to the maintenance burden it imposed.
    </p>
    <p>
        They humoured me as long as I stayed on, but also explicitly told me that they'd rip it out as soon as I was gone. In the meantime, I became the Castle Windsor bottleneck. Everything related to that piece of technology had to go through me, since I was the only person who understood how it worked.
    </p>
    <p>
        A few years later, I returned to that team and that code base on a new project, and they'd kept their word. They'd removed Castle Windsor in favour of <a href="/2014/06/10/pure-di">Pure DI</a>, bless them.
    </p>
    <p>
        This experience was crucial in making me realize that, despite their intellectual attraction, DI Containers are rarely the correct choice.
    </p>
    <p>
        Free monads look to me as though they belong to the same category. While I don't have a similar story to tell, I'm wary of recommending them unless other options are played out. I'll refer you to the decision flowchart in the article <a href="/2017/08/07/f-free-monad-recipe">F# free monad recipe</a>.
    </p>
    <h3 id="3c98545a69c042f19a304ac36db1392f">
        Language support <a href="#3c98545a69c042f19a304ac36db1392f">#</a>
    </h3>
    <p>
        Another concern about free monads is whether your language of choice supports them. They fit perfectly in <a href="https://www.haskell.org/">Haskell</a>, which is also the reason I start this sub-series of articles with a Haskell example.
    </p>
    <ul>
        <li><a href="/2025/08/18/song-recommendations-with-haskell-free-monads">Song recommendations with Haskell free monads</a></li>
        <li><a href="/2025/08/25/song-recommendations-with-f-free-monads">Song recommendations with F# free monads</a></li>
        <li><a href="/2025/09/01/song-recommendations-with-c-free-monads">Song recommendations with C# free monads</a></li>
    </ul>
    <p>
        In F# you'll have to do some more legwork, but once you've added the required infrastructure, the 'user code' based on free monads is perfectly fine.
    </p>
    <p>
        C#, on the other hand, doesn't have all the language features that will make free monads a good experience. I wouldn't suggest using a free monad in C#. I include the article with the C# free monad for demonstration purposes only.
    </p>
    <p>
        These articles will not introduce free monads to novice readers. For a gentler introduction, see the article series <a href="/2017/07/10/pure-interactions">Pure interactions</a>.
    </p>
    <h3 id="2d17efd5d83346ddb73c33d991da8096">
        Conclusion <a href="#2d17efd5d83346ddb73c33d991da8096">#</a>
    </h3>
    <p>
        When all else fails, and you just <em>must</em> write <a href="https://en.wikipedia.org/wiki/Pure_function">pure functions</a>, reach for free monads. They are not for everyone, or every language, but they do offer a functional solution to problems with large data sets or rich interaction with users or the environment.
    </p>
    <p>
        <strong>Next:</strong> <a href="/2025/08/18/song-recommendations-with-haskell-free-monads">Song recommendations with Haskell free monads</a>.
    </p>
</div>