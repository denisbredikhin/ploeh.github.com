---
layout: post
title: "Implementation and usage mindsets"
description: "A one-dimensional take on the enduring static-versus-dynamic debate."
date: 2024-12-09 21:45 UTC
tags: [Article Series, Languages]
image: "/content/binary/implementation-versus-usage.png"
image_alt: "A question mark in the middle. An arrow from left labelled 'implementation' points to the question mark from a figure indicating a person. Another arrow from the right labelled 'usage' points to the question mark from another figure indicating a person."
---
{% include JB/setup %}

<div id="post">
    <p>
        <em>{{ page.description }}</em>
    </p>
    <p>
        It recently occurred to me that one possible explanation for the standing, and probably never-ending, debate about static versus dynamic types may be that each camp have disjoint perspectives on the kinds of problems their favourite languages help them solve. In short, my hypothesis is that perhaps lovers of dynamically-typed languages often approach a problem from an implementation mindset, whereas proponents of static types emphasize usage.
    </p>
    <p>
        <img src="/content/binary/implementation-versus-usage.png" alt="A question mark in the middle. An arrow from left labelled 'implementation' points to the question mark from a figure indicating a person. Another arrow from the right labelled 'usage' points to the question mark from another figure indicating a person.">
    </p>
    <p>
        I'll expand on this idea here, and then provide examples in two subsequent articles.
    </p>
    <h3 id="d748f29ae31543fbb6db537711800c62">
        Background <a href="#d748f29ae31543fbb6db537711800c62">#</a>
    </h3>
    <p>
        For years I've struggled to understand 'the other side'. While I'm firmly in the statically typed camp, I realize that many highly skilled programmers and thought leaders enjoy, or get great use out of, dynamically typed languages. This worries me, because it <a href="/2021/08/09/am-i-stuck-in-a-local-maximum">might indicate that I'm stuck in a local maximum</a>.
    </p>
    <p>
        In other words, just because I, personally, prefer static types, it doesn't follow that static types are universally better than dynamic types.
    </p>
    <p>
        In reality, it's probably rather the case that we're dealing with a false dichotomy, and that the problem is really multi-dimensional.
    </p>
    <blockquote>
        <p>
            "Let me stop you right there: I don't think there is a real dynamic typing versus static typing debate.
        </p>
        <p>
            "What such debates normally are is language X vs language Y debates (where X happens to be dynamic and Y happens to be static)."
        </p>
        <footer><cite><a href="https://twitter.com/KevlinHenney/status/1425513161252278280">Kevlin Henney</a></cite></footer>
    </blockquote>
    <p>
        Even so, I can't help thinking about such things. Am I missing something?
    </p>
    <p>
        For the past few years, I've dabbled with <a href="https://www.python.org/">Python</a> to see what writing in a popular dynamically typed language is like. It's not a bad language, and I can clearly see how it's attractive. Even so, I'm still frustrated every time I return to some Python code after a few weeks or more. The lack of static types makes it hard for me to pick up, or revisit, old code.
    </p>
    <h3 id="8b6d87e0536d40b6aaec28d8e6356553">
        A question of perspective? <a href="#8b6d87e0536d40b6aaec28d8e6356553">#</a>
    </h3>
    <p>
        Whenever I run into a difference of opinion, I often interpret it as a difference in perspective. Perhaps it's my academic background as an economist, but I consider it a given that people have different motivations, and that incentives influence actions.
    </p>
    <p>
        A related kind of analysis deals with problem definitions. Are we even trying to solve the same problem?
    </p>
    <p>
        I've <a href="/2021/08/09/am-i-stuck-in-a-local-maximum">discussed such questions before, but in a different context</a>. Here, it strikes me that perhaps programmers who gravitate toward dynamically typed languages are focused on another problem than the other group.
    </p>
    <p>
        Again, I'd like to emphasize that I don't consider the world so black and white in reality. Some developers straddle the two camps, and as the above Kevlin Henney quote suggests, there really aren't only two kinds of languages. <a href="https://en.wikipedia.org/wiki/C_(programming_language)">C</a> and <a href="https://www.haskell.org/">Haskell</a> are both statically typed, but the similarities stop there. Likewise, I don't know if it's fair to put JavaScript and <a href="https://clojure.org/">Clojure</a> in the same bucket.
    </p>
    <p>
        That said, I'd still like to offer the following hypothesis, in the spirit that although <a href="https://en.wikipedia.org/wiki/All_models_are_wrong">all models are wrong</a>, some are useful.
    </p>
    <p>
        The idea is that if you're trying to solve a problem related to <em>implementation</em>, dynamically typed languages may be more suitable. If you're trying to implement an algorithm, or even trying to invent one, a dynamic language seems useful. One year, I did a good chunk of <a href="https://adventofcode.com/">Advent of Code</a> in Python, and didn't find it harder than in Haskell. (I ultimately ran out of steam for reasons unrelated to Python.)
    </p>
    <p>
        On the other hand, if your main focus may be <em>usage</em> of your code, perhaps you'll find a statically typed language more useful. At least, I do. I can use the static type system to communicate how my APIs work. How to instantiate my classes. How to call my functions. How return values are shaped. In other words, the preconditions, invariants, and postconditions of my reusable code: <a href="/encapsulation-and-solid/">Encapsulation</a>.
    </p>
    <h3 id="f0cbf02e11484e9a8c8d0fab9a6463f2">
        Examples <a href="#f0cbf02e11484e9a8c8d0fab9a6463f2">#</a>
    </h3>
    <p>
        Some examples may be in order. In the next two articles, I'll first examine how easy it is to implement an algorithm in various programming languages. Then I'll discuss how to encapsulate that algorithm.
    </p>
    <ul>
        <li><a href="/2024/12/23/implementing-rod-cutting">Implementing rod-cutting</a></li>
        <li><a href="/2025/01/06/encapsulating-rod-cutting">Encapsulating rod-cutting</a></li>
    </ul>
    <p>
        The articles will both discuss the rod-cutting problem from <a href="/ref/clrs">Introduction to Algorithms</a>, but I'll introduce the problem in the next article.
    </p>
    <h3 id="97b3e722024b4228924faa2d6ff5d188">
        Conclusion <a href="#97b3e722024b4228924faa2d6ff5d188">#</a>
    </h3>
    <p>
        I'd be naive if I believed that a single model can fully explain why some people prefer dynamically typed languages, and others rather like statically typed languages. Even so, suggesting a model helps me understand how to analyze problems.
    </p>
    <p>
        My hypothesis is that dynamically typed languages may be suitable for implementing algorithms, whereas statically typed languages offer better encapsulation.
    </p>
    <p>
        This may be used as a heuristic for 'picking the right tool for the job'. If I need to suss out an algorithm, perhaps I should do it in Python. If, on the other hand, I need to publish a reusable library, perhaps Haskell is a better choice.
    </p>
    <p>
        <strong>Next:</strong> <a href="/2024/12/23/implementing-rod-cutting">Implementing rod-cutting</a>.
    </p>
</div>