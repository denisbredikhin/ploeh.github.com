---
layout: post
title: "Lazy monoids"
description: "Lazy monoids are monoids. An article for object-oriented programmers."
date: 2019-04-15 13:54 UTC
tags: [Software Design]
---
{% include JB/setup %}

<div id="post">
	<p>
		<em>{{ page.description }}</em>
	</p>
	<p>
		This article is part of a <a href="/2017/10/06/monoids">series about monoids</a>. In short, a <em>monoid</em> is an associative binary operation with a neutral element (also known as <em>identity</em>). Previous articles have shown how more complex monoids arise from simpler monoids, such as <a href="/2017/10/30/tuple-monoids">tuple monoids</a>, <a href="/2017/11/06/function-monoids">function monoids</a>, and <a href="/2018/04/03/maybe-monoids">Maybe monoids</a>. This article shows another such result: how lazy computations of monoids itself form monoids.
	</p>
	<p>
		You'll see how simple this is through a series of examples. Specifically, you'll revisit several of the examples you've already seen in this article series.
	</p>
	<h3 id="a715cff45376401db9863a095a5e156d">
		Lazy addition <a href="#a715cff45376401db9863a095a5e156d" title="permalink">#</a>
	</h3>
	<p>
		Perhaps the most intuitive monoid is <em>addition</em>. Lazy addition forms a monoid as well. In C#, you can implement this with a simple extension method:
	</p>
	<p>
		<pre><span style="color:blue;">public</span>&nbsp;<span style="color:blue;">static</span>&nbsp;<span style="color:#2b91af;">Lazy</span>&lt;<span style="color:blue;">int</span>&gt;&nbsp;Add(<span style="color:blue;">this</span>&nbsp;<span style="color:#2b91af;">Lazy</span>&lt;<span style="color:blue;">int</span>&gt;&nbsp;x,&nbsp;<span style="color:#2b91af;">Lazy</span>&lt;<span style="color:blue;">int</span>&gt;&nbsp;y)
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">return</span>&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">Lazy</span>&lt;<span style="color:blue;">int</span>&gt;(()&nbsp;=&gt;&nbsp;x.Value&nbsp;+&nbsp;y.Value);
}</pre>
	</p>
	<p>
		This <code>Add</code> method simply adds two lazy integers together in a lazy computation. You use it like any other extension method:
	</p>
	<p>
		<pre><span style="color:#2b91af;">Lazy</span>&lt;<span style="color:blue;">int</span>&gt;&nbsp;x&nbsp;=&nbsp;<span style="color:green;">//&nbsp;...</span>
<span style="color:#2b91af;">Lazy</span>&lt;<span style="color:blue;">int</span>&gt;&nbsp;y&nbsp;=&nbsp;<span style="color:green;">//&nbsp;...</span> 
<span style="color:#2b91af;">Lazy</span>&lt;<span style="color:blue;">int</span>&gt;&nbsp;sum&nbsp;=&nbsp;x.Add(y);</pre>
	</p>
	<p>
		I'll spare you the tedious listing of <a href="https://fscheck.github.io/FsCheck">FsCheck</a>-based properties that demonstrate that the monoid laws hold. We'll look at an example of such a set of properties later in this article, for one of the other monoids.
	</p>
	<h3 id="eda5d39029904d70995ebee84570cf60">
		Lazy multiplication <a href="#eda5d39029904d70995ebee84570cf60" title="permalink">#</a>
	</h3>
	<p>
		Not surprisingly, I hope, you can implement multiplication over lazy numbers in the same way:
	</p>
	<p>
		<pre><span style="color:blue;">public</span>&nbsp;<span style="color:blue;">static</span>&nbsp;<span style="color:#2b91af;">Lazy</span>&lt;<span style="color:blue;">int</span>&gt;&nbsp;Multiply(<span style="color:blue;">this</span>&nbsp;<span style="color:#2b91af;">Lazy</span>&lt;<span style="color:blue;">int</span>&gt;&nbsp;x,&nbsp;<span style="color:#2b91af;">Lazy</span>&lt;<span style="color:blue;">int</span>&gt;&nbsp;y)
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">return</span>&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">Lazy</span>&lt;<span style="color:blue;">int</span>&gt;(()&nbsp;=&gt;&nbsp;x.Value&nbsp;*&nbsp;y.Value);
}</pre>
	</p>
	<p>
		Usage is similar to lazy addition:
	</p>
	<p>
		<pre><span style="color:#2b91af;">Lazy</span>&lt;<span style="color:blue;">int</span>&gt;&nbsp;x&nbsp;=&nbsp;<span style="color:green;">//&nbsp;...</span>
<span style="color:#2b91af;">Lazy</span>&lt;<span style="color:blue;">int</span>&gt;&nbsp;y&nbsp;=&nbsp;<span style="color:green;">//&nbsp;...</span>
<span style="color:#2b91af;">Lazy</span>&lt;<span style="color:blue;">int</span>&gt;&nbsp;product&nbsp;=&nbsp;x.Multiply(y);</pre>
	</p>
	<p>
		As is the case with lazy addition, this <code>Multiply</code> method currently only works with lazy <code>int</code> values. If you also want it to work with <code>long</code>, <code>short</code>, or other types of numbers, you'll have to add method overloads.
	</p>
	<h3 id="93b85bb3c55045dabdb16fd11167dad7">
		Lazy Boolean monoids <a href="#93b85bb3c55045dabdb16fd11167dad7" title="permalink">#</a>
	</h3>
	<p>
		There are four monoids over Boolean values, although I've customarily only shown two of them: <em>and</em> and <em>or</em>. These also, trivially, work with lazy Boolean values:
	</p>
	<p>
		<pre><span style="color:blue;">public</span>&nbsp;<span style="color:blue;">static</span>&nbsp;<span style="color:#2b91af;">Lazy</span>&lt;<span style="color:blue;">bool</span>&gt;&nbsp;And(<span style="color:blue;">this</span>&nbsp;<span style="color:#2b91af;">Lazy</span>&lt;<span style="color:blue;">bool</span>&gt;&nbsp;x,&nbsp;<span style="color:#2b91af;">Lazy</span>&lt;<span style="color:blue;">bool</span>&gt;&nbsp;y)
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">return</span>&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">Lazy</span>&lt;<span style="color:blue;">bool</span>&gt;(()&nbsp;=&gt;&nbsp;x.Value&nbsp;&amp;&amp;&nbsp;y.Value);
}
 
<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">static</span>&nbsp;<span style="color:#2b91af;">Lazy</span>&lt;<span style="color:blue;">bool</span>&gt;&nbsp;Or(<span style="color:blue;">this</span>&nbsp;<span style="color:#2b91af;">Lazy</span>&lt;<span style="color:blue;">bool</span>&gt;&nbsp;x,&nbsp;<span style="color:#2b91af;">Lazy</span>&lt;<span style="color:blue;">bool</span>&gt;&nbsp;y)
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">return</span>&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">Lazy</span>&lt;<span style="color:blue;">bool</span>&gt;(()&nbsp;=&gt;&nbsp;x.Value&nbsp;||&nbsp;y.Value);
}</pre>
	</p>
	<p>
		Given the previous examples, you'll hardly be surprised to see how you can use one of these extension methods:
	</p>
	<p>
		<pre><span style="color:#2b91af;">Lazy</span>&lt;<span style="color:blue;">bool</span>&gt;&nbsp;x&nbsp;=&nbsp;<span style="color:green;">//&nbsp;...</span>
<span style="color:#2b91af;">Lazy</span>&lt;<span style="color:blue;">bool</span>&gt;&nbsp;y&nbsp;=&nbsp;<span style="color:green;">//&nbsp;...</span>
<span style="color:#2b91af;">Lazy</span>&lt;<span style="color:blue;">bool</span>&gt;&nbsp;b&nbsp;=&nbsp;x.And(y);</pre>
	</p>
	<p>
		Have you noticed a pattern in how the lazy binary operations <code>Add</code>, <code>Multiply</code>, <code>And</code>, and <code>Or</code> are implemented? Could this be generalised?
	</p>
	<h3 id="12b7d0077481413cab6acf8f6bf696cf">
		Lazy angular addition <a href="#12b7d0077481413cab6acf8f6bf696cf" title="permalink">#</a>
	</h3>
	<p>
		In a previous article you saw how <a href="/2018/07/16/angular-addition-monoid">angular addition forms a monoid</a>. Lazy angular addition forms a monoid as well, which you can implement with another extension method:
	</p>
	<p>
		<pre><span style="color:blue;">public</span>&nbsp;<span style="color:blue;">static</span>&nbsp;<span style="color:#2b91af;">Lazy</span>&lt;<span style="color:#2b91af;">Angle</span>&gt;&nbsp;Add(<span style="color:blue;">this</span>&nbsp;<span style="color:#2b91af;">Lazy</span>&lt;<span style="color:#2b91af;">Angle</span>&gt;&nbsp;x,&nbsp;<span style="color:#2b91af;">Lazy</span>&lt;<span style="color:#2b91af;">Angle</span>&gt;&nbsp;y)
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">return</span>&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">Lazy</span>&lt;<span style="color:#2b91af;">Angle</span>&gt;(()&nbsp;=&gt;&nbsp;x.Value.Add(y.Value));
}</pre>
	</p>
	<p>
		Until now, you may have noticed that all the extension methods seemed to follow a common pattern that looks like this:
	</p>
	<p>
		<pre><span style="color:blue;">return</span>&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">Lazy</span>&lt;<span style="color:#2b91af;">Foo</span>&gt;(()&nbsp;=&gt;&nbsp;x.Value&nbsp;&diamond;&nbsp;y.Value);</pre>
	</p>
	<p>
		I've here used the diamond operator <code>&diamond;</code> as a place-holder for any sort of binary operation. My choice of that particular character is strongly influenced by <a href="https://www.haskell.org">Haskell</a>, where <a href="/2017/11/27/semigroups">semigroups</a> and monoids polymorphically are modelled with (among other options) the <code>&lt;&gt;</code> operator.
	</p>
	<p>
		The lazy angular addition implementation looks a bit different, though. This is because the original example uses an instance method to model the binary operation, instead of an infix operator such as <code>+</code>, <code>&&</code>, and so on. Given that the implementation of a lazy binary operation can also look like this, can you still imagine a generalisation?
	</p>
	<h3 id="669710b096144c6d8aaaca4426f8f795">
		Lazy string concatenation <a href="#669710b096144c6d8aaaca4426f8f795" title="permalink">#</a>
	</h3>
	<p>
		If we follow the rough ordering of examples introduced in this article series about monoids, we've now reached <a href="/2017/10/10/strings-lists-and-sequences-as-a-monoid">concatenation as a monoid</a>. While various lists, arrays, and other sorts of collections also form a monoid over concatenation, in .NET, <code>IEnumerable&lt;T&gt;</code> already enables lazy evaluation, so I think it's more interesting to consider lazy string concatenation.
	</p>
	<p>
		The implementation, however, holds few surprises:
	</p>
	<p>
		<pre><span style="color:blue;">public</span>&nbsp;<span style="color:blue;">static</span>&nbsp;<span style="color:#2b91af;">Lazy</span>&lt;<span style="color:blue;">string</span>&gt;&nbsp;Concat(<span style="color:blue;">this</span>&nbsp;<span style="color:#2b91af;">Lazy</span>&lt;<span style="color:blue;">string</span>&gt;&nbsp;x,&nbsp;<span style="color:#2b91af;">Lazy</span>&lt;<span style="color:blue;">string</span>&gt;&nbsp;y)
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">return</span>&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">Lazy</span>&lt;<span style="color:blue;">string</span>&gt;(()&nbsp;=&gt;&nbsp;x.Value&nbsp;+&nbsp;y.Value);
}</pre>
	</p>
	<p>
		The overall result, so far, seems encouraging. All the basic monoids we've covered are also monoids when lazily computed.
	</p>
	<h3 id="29df873ebae145e2b903f6562825b69e">
		Lazy money addition <a href="#29df873ebae145e2b903f6562825b69e" title="permalink">#</a>
	</h3>
	<p>
		The portfolio example from Kent Beck's book <a href="http://bit.ly/tddbe">Test-Driven Development By Example</a> also <a href="/2017/10/16/money-monoid">forms a monoid</a>. You can, again, implement an extension method that enables you to add lazy expressions together:
	</p>
	<p>
		<pre><span style="color:blue;">public</span>&nbsp;<span style="color:blue;">static</span>&nbsp;<span style="color:#2b91af;">Lazy</span>&lt;<span style="color:#2b91af;">IExpression</span>&gt;&nbsp;Plus(
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">this</span>&nbsp;<span style="color:#2b91af;">Lazy</span>&lt;<span style="color:#2b91af;">IExpression</span>&gt;&nbsp;source,
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">Lazy</span>&lt;<span style="color:#2b91af;">IExpression</span>&gt;&nbsp;addend)
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">return</span>&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">Lazy</span>&lt;<span style="color:#2b91af;">IExpression</span>&gt;(()&nbsp;=&gt;&nbsp;source.Value.Plus(addend.Value));
}</pre>
	</p>
	<p>
		So far, you've seen several examples of implementations, but are they really monoids? All are clearly binary operations, but are they associative? Do identities exist? In other words, do the lazy binary operations obey the monoid laws?
	</p>
	<p>
		As usual, I'm not going to prove that they do, but I do want to share a set of FsCheck properties that demonstrate that the monoid laws hold. As an example, I'll share the properties for this lazy <code>Plus</code> method, but you can write similar properties for all of the above methods as well.
	</p>
	<p>
		You can verify the associativity law like this:
	</p>
	<p>
		<pre><span style="color:blue;">public</span>&nbsp;<span style="color:blue;">void</span>&nbsp;LazyPlusIsAssociative(
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">Lazy</span>&lt;<span style="color:#2b91af;">IExpression</span>&gt;&nbsp;x,
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">Lazy</span>&lt;<span style="color:#2b91af;">IExpression</span>&gt;&nbsp;y,
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">Lazy</span>&lt;<span style="color:#2b91af;">IExpression</span>&gt;&nbsp;z)
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">Assert</span>.Equal(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x.Plus(y).Plus(z),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x.Plus(y.Plus(z)),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">Compare</span>.UsingBank);
}</pre>
	</p>
	<p>
		Here, <code>Compare.UsingBank</code> is just a <a href="http://xunitpatterns.com/Test%20Utility%20Method.html">test utility API</a> to make the code more readable:
	</p>
	<p>
		<pre><span style="color:blue;">public</span>&nbsp;<span style="color:blue;">static</span>&nbsp;<span style="color:blue;">class</span>&nbsp;<span style="color:#2b91af;">Compare</span>
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">static</span>&nbsp;<span style="color:#2b91af;">ExpressionEqualityComparer</span>&nbsp;UsingBank&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">ExpressionEqualityComparer</span>();
}</pre>
	</p>
	<p>
		This takes advantage of the overloads for <a href="https://xunit.net">xUnit.net</a>'s <code>Assert</code> methods that take custom equality comparers as an extra, optional argument. <code>ExpressionEqualityComparer</code> is implemented in the test code base:
	</p>
	<p>
		<pre><span style="color:blue;">public</span>&nbsp;<span style="color:blue;">class</span>&nbsp;<span style="color:#2b91af;">ExpressionEqualityComparer</span>&nbsp;:
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">IEqualityComparer</span>&lt;<span style="color:#2b91af;">IExpression</span>&gt;,&nbsp;<span style="color:#2b91af;">IEqualityComparer</span>&lt;<span style="color:#2b91af;">Lazy</span>&lt;<span style="color:#2b91af;">IExpression</span>&gt;&gt;
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">private</span>&nbsp;<span style="color:blue;">readonly</span>&nbsp;<span style="color:#2b91af;">Bank</span>&nbsp;bank;
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;ExpressionEqualityComparer()
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bank&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">Bank</span>();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bank.AddRate(<span style="color:#a31515;">&quot;CHF&quot;</span>,&nbsp;<span style="color:#a31515;">&quot;USD&quot;</span>,&nbsp;2);
&nbsp;&nbsp;&nbsp;&nbsp;}
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">bool</span>&nbsp;Equals(<span style="color:#2b91af;">IExpression</span>&nbsp;x,&nbsp;<span style="color:#2b91af;">IExpression</span>&nbsp;y)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;xm&nbsp;=&nbsp;bank.Reduce(x,&nbsp;<span style="color:#a31515;">&quot;USD&quot;</span>);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;ym&nbsp;=&nbsp;bank.Reduce(y,&nbsp;<span style="color:#a31515;">&quot;USD&quot;</span>);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">return</span>&nbsp;<span style="color:blue;">object</span>.Equals(xm,&nbsp;ym);
&nbsp;&nbsp;&nbsp;&nbsp;}
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">int</span>&nbsp;GetHashCode(<span style="color:#2b91af;">IExpression</span>&nbsp;obj)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">return</span>&nbsp;bank.Reduce(obj,&nbsp;<span style="color:#a31515;">&quot;USD&quot;</span>).GetHashCode();
&nbsp;&nbsp;&nbsp;&nbsp;}
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">bool</span>&nbsp;Equals(<span style="color:#2b91af;">Lazy</span>&lt;<span style="color:#2b91af;">IExpression</span>&gt;&nbsp;x,&nbsp;<span style="color:#2b91af;">Lazy</span>&lt;<span style="color:#2b91af;">IExpression</span>&gt;&nbsp;y)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">return</span>&nbsp;Equals(x.Value,&nbsp;y.Value);
&nbsp;&nbsp;&nbsp;&nbsp;}
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">int</span>&nbsp;GetHashCode(<span style="color:#2b91af;">Lazy</span>&lt;<span style="color:#2b91af;">IExpression</span>&gt;&nbsp;obj)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">return</span>&nbsp;GetHashCode(obj.Value);
&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre>
	</p>
	<p>
		If you think that the exchange rate between Dollars and Swiss Francs looks ridiculous, it's because I'm using the rate that Kent Beck used in his book, which is from 2002 (but otherwise timeless).
	</p>
	<p>
		The above property passes for hundreds of randomly generated input values, as is the case for this property, which verifies the left and right identity:
	</p>
	<p>
		<pre><span style="color:blue;">public</span>&nbsp;<span style="color:blue;">void</span>&nbsp;LazyPlusHasIdentity(<span style="color:#2b91af;">Lazy</span>&lt;<span style="color:#2b91af;">IExpression</span>&gt;&nbsp;x)
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">Assert</span>.Equal(x,&nbsp;x.Plus(<span style="color:#2b91af;">Plus</span>.Identity.ToLazy()),&nbsp;<span style="color:#2b91af;">Compare</span>.UsingBank);
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">Assert</span>.Equal(x,&nbsp;<span style="color:#2b91af;">Plus</span>.Identity.ToLazy().Plus(x),&nbsp;<span style="color:#2b91af;">Compare</span>.UsingBank);
}</pre>
	</p>
	<p>
		These properties are just examples, not proofs. Still, they give confidence that lazy computations of monoids are themselves monoids.
	</p>
	<h3 id="6b5aa8f3a0b34d4c9d145eac3e59fe9b">
		Lazy Roster combinations <a href="#6b5aa8f3a0b34d4c9d145eac3e59fe9b" title="permalink">#</a>
	</h3>
	<p>
		The last example you'll get in this article is the <code>Roster</code> example from the article on <a href="/2017/10/30/tuple-monoids">tuple monoids</a>. Here's yet another extension method that enables you to combine two lazy rosters:
	</p>
	<p>
		<pre><span style="color:blue;">public</span>&nbsp;<span style="color:blue;">static</span>&nbsp;<span style="color:#2b91af;">Lazy</span>&lt;<span style="color:#2b91af;">Roster</span>&gt;&nbsp;Combine(<span style="color:blue;">this</span>&nbsp;<span style="color:#2b91af;">Lazy</span>&lt;<span style="color:#2b91af;">Roster</span>&gt;&nbsp;x,&nbsp;<span style="color:#2b91af;">Lazy</span>&lt;<span style="color:#2b91af;">Roster</span>&gt;&nbsp;y)
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">return</span>&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">Lazy</span>&lt;<span style="color:#2b91af;">Roster</span>&gt;(()&nbsp;=&gt;&nbsp;x.Value.Combine(y.Value));
}</pre>
	</p>
	<p>
		At this point it should be clear that there's essentially two variations in how the above extension methods are implemented. One variation is when the binary operation is implemented with an infix operator (like <code>+</code>, <code>||</code>, and so on), and another variation is when it's modelled as an instance method. How do these implementations generalise?
	</p>
	<p>
		I'm sure you could come up with an ad-hoc higher-order function, abstract base class, or interface to model such a generalisation, but I'm not motivated by <a href="/2018/09/17/typing-is-not-a-programming-bottleneck">saving keystrokes</a>. What I'm trying to uncover with this <a href="/2017/10/04/from-design-patterns-to-category-theory">overall article series</a> is how universal abstractions apply to programming.
	</p>
	<p>
		Which universal abstraction is in play here?
	</p>
	<h3 id="6d247327cf214fa698dc9ec29693bd6f">
		Lazy monoids as applicative operations <a href="#6d247327cf214fa698dc9ec29693bd6f" title="permalink">#</a>
	</h3>
	<p>
		<a href="/2018/12/17/the-lazy-applicative-functor">Lazy&lt;T&gt; forms an applicative functor</a>. Using appropriate <code>Apply</code> overloads, you can rewrite all the above implementations in applicative style. Here's lazy addition:
	</p>
	<p>
		<pre><span style="color:blue;">public</span>&nbsp;<span style="color:blue;">static</span>&nbsp;<span style="color:#2b91af;">Lazy</span>&lt;<span style="color:blue;">int</span>&gt;&nbsp;Add(<span style="color:blue;">this</span>&nbsp;<span style="color:#2b91af;">Lazy</span>&lt;<span style="color:blue;">int</span>&gt;&nbsp;x,&nbsp;<span style="color:#2b91af;">Lazy</span>&lt;<span style="color:blue;">int</span>&gt;&nbsp;y)
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">Func</span>&lt;<span style="color:blue;">int</span>,&nbsp;<span style="color:blue;">int</span>,&nbsp;<span style="color:blue;">int</span>&gt;&nbsp;f&nbsp;=&nbsp;(i,&nbsp;j)&nbsp;=&gt;&nbsp;i&nbsp;+&nbsp;j;
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">return</span>&nbsp;f.Apply(x).Apply(y);
}</pre>
	</p>
	<p>
		This first declares a <code>Func</code> value <code>f</code> that invokes the non-lazy binary operation, in this case <code>+</code>. Next, you can leverage the applicative nature of <code>Lazy&lt;T&gt;</code> to apply <code>f</code> to the two lazy values <code>x</code> and <code>y</code>.
	</p>
	<p>
		Multiplication, as well as the Boolean operations, follow the exact same template:
	</p>
	<p>
		<pre><span style="color:blue;">public</span>&nbsp;<span style="color:blue;">static</span>&nbsp;<span style="color:#2b91af;">Lazy</span>&lt;<span style="color:blue;">int</span>&gt;&nbsp;Multiply(<span style="color:blue;">this</span>&nbsp;<span style="color:#2b91af;">Lazy</span>&lt;<span style="color:blue;">int</span>&gt;&nbsp;x,&nbsp;<span style="color:#2b91af;">Lazy</span>&lt;<span style="color:blue;">int</span>&gt;&nbsp;y)
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">Func</span>&lt;<span style="color:blue;">int</span>,&nbsp;<span style="color:blue;">int</span>,&nbsp;<span style="color:blue;">int</span>&gt;&nbsp;f&nbsp;=&nbsp;(i,&nbsp;j)&nbsp;=&gt;&nbsp;i&nbsp;*&nbsp;j;
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">return</span>&nbsp;f.Apply(x).Apply(y);
}
 
<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">static</span>&nbsp;<span style="color:#2b91af;">Lazy</span>&lt;<span style="color:blue;">bool</span>&gt;&nbsp;And(<span style="color:blue;">this</span>&nbsp;<span style="color:#2b91af;">Lazy</span>&lt;<span style="color:blue;">bool</span>&gt;&nbsp;x,&nbsp;<span style="color:#2b91af;">Lazy</span>&lt;<span style="color:blue;">bool</span>&gt;&nbsp;y)
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">Func</span>&lt;<span style="color:blue;">bool</span>,&nbsp;<span style="color:blue;">bool</span>,&nbsp;<span style="color:blue;">bool</span>&gt;&nbsp;f&nbsp;=&nbsp;(b1,&nbsp;b2)&nbsp;=&gt;&nbsp;b1&nbsp;&amp;&amp;&nbsp;b2;
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">return</span>&nbsp;f.Apply(x).Apply(y);
}
 
<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">static</span>&nbsp;<span style="color:#2b91af;">Lazy</span>&lt;<span style="color:blue;">bool</span>&gt;&nbsp;Or(<span style="color:blue;">this</span>&nbsp;<span style="color:#2b91af;">Lazy</span>&lt;<span style="color:blue;">bool</span>&gt;&nbsp;x,&nbsp;<span style="color:#2b91af;">Lazy</span>&lt;<span style="color:blue;">bool</span>&gt;&nbsp;y)
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">Func</span>&lt;<span style="color:blue;">bool</span>,&nbsp;<span style="color:blue;">bool</span>,&nbsp;<span style="color:blue;">bool</span>&gt;&nbsp;f&nbsp;=&nbsp;(b1,&nbsp;b2)&nbsp;=&gt;&nbsp;b1&nbsp;||&nbsp;b2;
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">return</span>&nbsp;f.Apply(x).Apply(y);
}</pre>
	</p>
	<p>
		Notice that in all four implementations, the second line of code is verbatim the same: <code>return f.Apply(x).Apply(y);</code>
	</p>
	<p>
		Does this generalisation also hold when the underlying, non-lazy binary operation is modelled as an instance method, as is the case of e.g. angular addition? Yes, indeed:
	</p>
	<p>
		<pre><span style="color:blue;">public</span>&nbsp;<span style="color:blue;">static</span>&nbsp;<span style="color:#2b91af;">Lazy</span>&lt;<span style="color:#2b91af;">Angle</span>&gt;&nbsp;Add(<span style="color:blue;">this</span>&nbsp;<span style="color:#2b91af;">Lazy</span>&lt;<span style="color:#2b91af;">Angle</span>&gt;&nbsp;x,&nbsp;<span style="color:#2b91af;">Lazy</span>&lt;<span style="color:#2b91af;">Angle</span>&gt;&nbsp;y)
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">Func</span>&lt;<span style="color:#2b91af;">Angle</span>,&nbsp;<span style="color:#2b91af;">Angle</span>,&nbsp;<span style="color:#2b91af;">Angle</span>&gt;&nbsp;f&nbsp;=&nbsp;(i,&nbsp;j)&nbsp;=&gt;&nbsp;i.Add(j);
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">return</span>&nbsp;f.Apply(x).Apply(y);
}</pre>
	</p>
	<p>
		You can implement the <code>Combine</code> method for lazy <code>Roster</code> objects in the same way, as well as <code>Plus</code> for lazy monetary expressions. The latter is worth revisiting.
	</p>
	<h3 id="445af7622459483ab64f4ff31ceb1c2e">
		Using the Lazy functor over portfolio expressions <a href="#445af7622459483ab64f4ff31ceb1c2e" title="permalink">#</a>
	</h3>
	<p>
		The lazy <code>Plus</code> implementation looks like all of the above <code>Apply</code>-based implementations:
	</p>
	<p>
		<pre><span style="color:blue;">public</span>&nbsp;<span style="color:blue;">static</span>&nbsp;<span style="color:#2b91af;">Lazy</span>&lt;<span style="color:#2b91af;">IExpression</span>&gt;&nbsp;Plus(
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">this</span>&nbsp;<span style="color:#2b91af;">Lazy</span>&lt;<span style="color:#2b91af;">IExpression</span>&gt;&nbsp;source,&nbsp;<span style="color:#2b91af;">Lazy</span>&lt;<span style="color:#2b91af;">IExpression</span>&gt;&nbsp;addend)
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">Func</span>&lt;<span style="color:#2b91af;">IExpression</span>,&nbsp;<span style="color:#2b91af;">IExpression</span>,&nbsp;<span style="color:#2b91af;">IExpression</span>&gt;&nbsp;f&nbsp;=&nbsp;(x,&nbsp;y)&nbsp;=&gt;&nbsp;x.Plus(y);
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">return</span>&nbsp;f.Apply(source).Apply(addend);
}</pre>
	</p>
	<p>
		In my article, however, you saw how, when <code>Plus</code> is a monoid, you can implement <code>Times</code> as an extension method. Can you implement a lazy version of <code>Times</code> as well? Must it be another extension method?
	</p>
	<p>
		Yes, but instead of an ad-hoc implementation, you can take advantage of the functor nature of Lazy:
	</p>
	<p>
		<pre><span style="color:blue;">public</span>&nbsp;<span style="color:blue;">static</span>&nbsp;<span style="color:#2b91af;">Lazy</span>&lt;<span style="color:#2b91af;">IExpression</span>&gt;&nbsp;Times(<span style="color:blue;">this</span>&nbsp;<span style="color:#2b91af;">Lazy</span>&lt;<span style="color:#2b91af;">IExpression</span>&gt;&nbsp;exp,&nbsp;<span style="color:blue;">int</span>&nbsp;multiplier)
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">return</span>&nbsp;exp.Select(x&nbsp;=&gt;&nbsp;x.Times(multiplier));
}</pre>
	</p>
	<p>
		Notice that instead of explicitly reaching into the lazy <code>Value</code>, you can simply call <code>Select</code> on <code>exp</code>. This lazily projects the <code>Times</code> operation, while preserving the invariants of <code>Lazy&lt;T&gt;</code> (i.e. that the computation is deferred until you ultimately access the <code>Value</code> property).
	</p>
	<p>
		You can implement a lazy version of <code>Reduce</code> in the same way:
	</p>
	<p>
		<pre><span style="color:blue;">public</span>&nbsp;<span style="color:blue;">static</span>&nbsp;<span style="color:#2b91af;">Lazy</span>&lt;<span style="color:#2b91af;">Money</span>&gt;&nbsp;Reduce(<span style="color:blue;">this</span>&nbsp;<span style="color:#2b91af;">Lazy</span>&lt;<span style="color:#2b91af;">IExpression</span>&gt;&nbsp;exp,&nbsp;<span style="color:#2b91af;">Bank</span>&nbsp;bank,&nbsp;<span style="color:blue;">string</span>&nbsp;to)
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">return</span>&nbsp;exp.Select(x&nbsp;=&gt;&nbsp;x.Reduce(bank,&nbsp;to));
}</pre>
	</p>
	<p>
		The question is, however, is it even worthwhile? Do you need to create all these overloads, or could you just leverage <code>Select</code> when you have a lazy value?
	</p>
	<p>
		For example, if the above <code>Reduce</code> overload didn't exist, you'd still be able to work with the portfolio API like this:
	</p>
	<p>
		<pre><span style="color:#2b91af;">Lazy</span>&lt;<span style="color:#2b91af;">IExpression</span>&gt;&nbsp;portfolio&nbsp;=&nbsp;<span style="color:green;">//&nbsp;...</span>
<span style="color:#2b91af;">Lazy</span>&lt;<span style="color:#2b91af;">Money</span>&gt;&nbsp;result&nbsp;=&nbsp;portfolio.Select(x&nbsp;=&gt;&nbsp;x.Reduce(bank,&nbsp;<span style="color:#a31515;">&quot;USD&quot;</span>));</pre>
	</p>
	<p>
		If you only occasionally use <code>Reduce</code>, then perhaps this is good enough. If you frequently call <code>Reduce</code>, however, it might be worth to add the above overload, in which case you could then instead write:
	</p>
	<p>
		<pre><span style="color:#2b91af;">Lazy</span>&lt;<span style="color:#2b91af;">IExpression</span>&gt;&nbsp;portfolio&nbsp;=&nbsp;<span style="color:green;">//&nbsp;...</span>
<span style="color:#2b91af;">Lazy</span>&lt;<span style="color:#2b91af;">Money</span>&gt;&nbsp;result&nbsp;=&nbsp;portfolio.Reduce(bank,&nbsp;<span style="color:#a31515;">&quot;USD&quot;</span>);</pre>
	</p>
	<p>
		In both cases, however, I think that you'd be putting the concept of an applicative functor to good use.
	</p>
	<h3 id="a5942465683c459a92457ea13e3bd21d">
		Towards generalisation <a href="#a5942465683c459a92457ea13e3bd21d" title="permalink">#</a>
	</h3>
	<p>
		Is the applicative style better than the initial ad-hoc implementations? That depends on how you evaluate 'better'. If you count lines of code, then the applicative style is twice as verbose as the ad-hoc implementations. In other words, this:
	</p>
	<p>
		<pre><span style="color:blue;">return</span>&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">Lazy</span>&lt;<span style="color:blue;">int</span>&gt;(()&nbsp;=&gt;&nbsp;x.Value&nbsp;+&nbsp;y.Value);</pre>
	</p>
	<p>
		seems simpler than this:
	</p>
	<p>
		<pre><span style="color:#2b91af;">Func</span>&lt;<span style="color:blue;">int</span>,&nbsp;<span style="color:blue;">int</span>,&nbsp;<span style="color:blue;">int</span>&gt;&nbsp;f&nbsp;=&nbsp;(i,&nbsp;j)&nbsp;=&gt;&nbsp;i&nbsp;+&nbsp;j;
<span style="color:blue;">return</span>&nbsp;f.Apply(x).Apply(y);</pre>
	</p>
	<p>
		This is, however, mostly because C# is too weak to express such abstractions in an elegant way. In <a href="https://fsharp.org">F#</a>, using the custom <code>&lt;*&gt;</code> operator from <a href="/2018/12/17/the-lazy-applicative-functor">the article on the Lazy applicative functor</a>, you could express the lazy addition as simply as:
	</p>
	<p>
		<pre><span style="color:blue;">lazy</span>&nbsp;(+)&nbsp;&lt;*&gt;&nbsp;x&nbsp;&lt;*&gt;&nbsp;y</pre>
	</p>
	<p>
		In <a href="https://www.haskell.org">Haskell</a> (if we, once more, pretend that <code>Identity</code> is equivalent to <code>Lazy</code>), you can simplify even further to:
	</p>
	<p>
		<pre>(+) &lt;$&gt; x &lt;*&gt; y</pre>
	</p>
	<p>
		Or rather, if you want it in <a href="https://en.wikipedia.org/wiki/Tacit_programming">point-free style</a>, <code>liftA2 (+)</code>.
	</p>
	<h3 id="f418f44f772b44c287365c7054d51aa1">
		Summary <a href="#f418f44f772b44c287365c7054d51aa1" title="permalink">#</a>
	</h3>
	<p>
		The point of this article series isn't to save keystrokes, but to identify universal laws of computing, even as they relate to object-oriented programming. The pattern seems clear enough that I dare propose the following:
	</p>
	<p>
		<em>All monoids remain monoids under lazy computation.</em>
	</p>
	<p>
		In a future article I'll offer further support for that proposition.
	</p>
	<p>
		<strong>Next:</strong> <a href="/2017/11/20/monoids-accumulate">Monoids accumulate</a>.
	</p>
</div>
<div id="comments">
    <hr>
    <h2 id="comments-header">
        Comments
    </h2>
    <div class="comment" id="861167e818344e1497dac4329166d2ef">
        <div class="comment-author"><a href="https://github.com/idg10">Ian Griffiths</a> <a href="#861167e818344e1497dac4329166d2ef">#</a></div>
        <div class="comment-content">
		<p>In the <a href="#6d247327cf214fa698dc9ec29693bd6f">Lazy monoids as applicative operations</a> section, you mention "<code>Apply</code> overloads".
		In pondering what those might look like, I found the two examples in the <a href="https://blog.ploeh.dk/2018/10/01/applicative-functors/#cef395ee19644f30bfd1ad7a84b6f912">A C# perspective</a>
		section of your post on applicative functors, and from those, drew the conclusion that <code>Apply</code> for <code>Lazy&lt;T&gt;</code> would look like this:</p>

		<pre><span style="color:blue;">public</span>&nbsp;<span style="color:blue;">static</span>&nbsp;<span style="color:#2b91af;">Lazy</span>&lt;<span style="color:#2b91af;">TResult</span>&gt;&nbsp;Apply&lt;<span style="color:#2b91af;">T</span>,&nbsp;<span style="color:#2b91af;">TResult</span>&gt;(
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">this</span>&nbsp;<span style="color:#2b91af;">Lazy</span>&lt;<span style="color:#2b91af;">Func</span>&lt;<span style="color:#2b91af;">T</span>,&nbsp;<span style="color:#2b91af;">TResult</span>&gt;&gt;&nbsp;selector,
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">Lazy</span>&lt;<span style="color:#2b91af;">T</span>&gt;&nbsp;source)
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">return</span>&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">Lazy</span>&lt;<span style="color:#2b91af;">TResult</span>&gt;(()&nbsp;=&gt;&nbsp;selector.Value(source.Value));
}</pre>

		<p>
			You want to be able to use <code>Apply</code> against a two-argument function, and since C# doesn't curry functions, we've got a couple of options. We could define an additional <code>Apply</code> overload to handle
			two-argument functions. But since we're going to need to wrap up the function in a <code>Lazy</code> anyway, we could just curry while doing that:
		</p>
		<pre><span style="color:#2b91af;">Func</span>&lt;<span style="color:blue;">int</span>,&nbsp;<span style="color:blue;">int</span>,&nbsp;<span style="color:blue;">int</span>&gt;&nbsp;f&nbsp;=&nbsp;(i,&nbsp;j)&nbsp;=&gt;&nbsp;i&nbsp;+&nbsp;j;
<span style="color:blue;">return</span>&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">Lazy</span>&lt;<span style="color:#2b91af;">Func</span>&lt;<span style="color:blue;">int</span>,&nbsp;<span style="color:#2b91af;">Func</span>&lt;<span style="color:blue;">int</span>,&nbsp;<span style="color:blue;">int</span>&gt;&gt;&gt;(x =&gt; y =&gt; f(x,&nbsp;y)).Apply(x).Apply(y);
			</pre>
		<p>
			That seems in line not only with your formulation in the article on applicative functors, but also with how they look in Haskell: <code>Applicative</code> defines the first argument to <code>&lt;*&gt;</code> as being <code>f (a -&gt; b)</code>.
			In other words, the first argument to <code>Apply</code> is not a function, it's a function wrapped in a functor. In Haskell, that means doing something like this:
			<code>((Just (+)) &lt;*&gt; (Just 10)) &lt;*&gt; (Just 32)</code>
		</p>
			
		<p>
			But that's apparently not what you've done here. You've called <code>Apply</code> directly on a function (and not a function wrapped in <code>Lazy</code>). But isn't the point of applicative functors that it's not just values that are wrapped up in
			a functor: so, too, are the functions we might want to map over them, right? If you merely want to map a bare function over a functor, then you can just do that with <code>fmap</code> (or <code>Select</code>, as we normally call it in .NET).
			(That said, your definition is consistent with <code>liftA2</code>. But my understanding is that the ability to define an applicative
			in terms of <code>liftA2</code> is an optimization rather than a fundamental feature; originally only <code>&lt;*&gt</code> was part of the typeclass, with <code>liftA2</code> being defined in terms of <code>&lt;*&gt;</code> and <code>fmap</code>.)
		</p>
		<p>
			Not that <code>Select</code> alone would be sufficient here. If you are starting with an unwrapped function, you'd use <code>Select</code> to apply the first argument, but the result would be a <code>Lazy&lt;Func&lt;int, int&gt;&gt;</code>,
			so you would actually need to use <code>Apply</code> for the second step. So you'd end up with this oddity:
		</p>

		<pre><span style="color:#2b91af;">Func</span>&lt;<span style="color:blue;">int</span>,&nbsp;<span style="color:blue;">int</span>,&nbsp;<span style="color:blue;">int</span>&gt;&nbsp;f&nbsp;=&nbsp;(i,&nbsp;j)&nbsp;=&gt;&nbsp;i&nbsp;+&nbsp;j;
<span style="color:#2b91af;">Func</span>&lt;<span style="color:blue;">int</span>,&nbsp;<span style="color:#2b91af;">Func</span>&lt;<span style="color:blue;">int</span>,&nbsp;<span style="color:blue;">int</span>&gt;&gt;&nbsp;curried = x =&gt; y => f(x, y);
return curried.Select(x).Apply(y);
		</pre>

		<p>
			In Haskell, that would be equivalent to <code>((fmap (+)) (Just 10)) &lt;*&gt; (Just 32)</code>. Just like in the C# version, I'm using a plain function (<code>(+)</code>), not wrapped in a functor, and so I have to
			use <code>fmap</code> (aka <code>Select</code>) to apply that unwrapped function to the value in the <code>Maybe</code>.
		</p>
		<p>
			Obviously we could avoid the manual currying in C# by defining overloads that work with 2-argument functions, but I don't think it would change the fundamental fact that with applicative functors, you
			apply a function wrapper in the functor, whereas if you just want to apply a function directly, that's ordinary functor <code>fmap</code> (aka <code>Select</code>).
		</p>
		<p>
			Weird though this look, it makes plain something that I think is obscured in your <code>...Apply(x).Apply(y)</code> examples: the application of the first argument is a quite different operation, because you're applying
			a lazy argument to a non-lazy function, but since the result is a lazy function, the application of the second argument needs to do something different: applying a lazy argument to a lazy function. Weird though
			<code>f.Select(x).Apply(x)</code> looks, it does make it clear that the two stages are not the same thing.
		</p>
        </div>
        <div class="comment-date">2025-02-25 18:40 UTC</div>
    </div>
</div>