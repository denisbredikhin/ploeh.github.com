---
layout: post
title: "Greyscale-box test-driven development"
description: "Is TDD white-box testing or black-box testing?"
date: 2025-06-26 6:46 UTC
tags: [Unit Testing]
image: "/content/binary/greyscale-tdd-spectrum.png"
image_alt: "Black-box testing to the left, white-box testing to the right, with four grey boxes of varying greyscales in between, all four labeled TDD."
---
{% include JB/setup %}

<div id="post">
    <p>
        <em>{{ page.description }}</em>
    </p>
    <p>
        Surely you're aware of the terms <a href="https://en.wikipedia.org/wiki/Black-box_testing">black-box testing</a> and <a href="https://en.wikipedia.org/wiki/White-box_testing">white-box testing</a>, but have you ever wondered where test-driven development (TDD) fits in that picture?
    </p>
    <p>
        The short answer is that TDD as a software development practice sits somewhere between the two. It really isn't black and white, and exactly where TDD sits on the spectrum changes with circumstances.
    </p>
    <p>
        <img src="/content/binary/greyscale-tdd-spectrum.png" alt="Black-box testing to the left, white-box testing to the right, with four grey boxes of varying greyscales in between, all four labeled TDD.">
    </p>
    <p>
        If the above diagram indicates that TDD can't occupy the space of undiluted black- or white-box testing, that's not my intent. In my experience, however, you rarely do neither when you engage with the TDD process. Rather, you find yourself somewhere in-between.
    </p>
    <p>
        In the following, I'll examine the two extremes in order to explain why TDD rarely leads to either, starting with black-box testing.
    </p>
    <h3 id="7b6ff977cede461f9c859e55e2aa24c9">
        Compartmentalization of knowledge <a href="#7b6ff977cede461f9c859e55e2aa24c9">#</a>
    </h3>
    <p>
        If you follow the usual <a href="/2019/10/21/a-red-green-refactor-checklist">red-green-refactor</a> checklist, you write test code and production code in tight loops. You write some test code, some production code, more test code, then more production code, and so on.
    </p>
    <p>
        If you're working by yourself, at least, that makes it almost impossible to treat the System Under Test (SUT) as a black box. After all, you're also the one who writes the production code.
    </p>
    <p>
        You can try to 'forget' the production code you just wrote whenever you circle back to writing another test, but in practice, you can't. Even so, it may still be a useful <a href="/2020/01/13/on-doing-katas">exercise</a>. I call this technique <em>Gollum style</em> (originally introduced in the Pluralsight course <a href="/outside-in-tdd">Outside-In Test-Driven Development</a> as a variation on the <a href="/2019/10/07/devils-advocate">Devil's advocate</a> technique). The idea is to assume two roles, and to explicitly distinguish the goals of the tester from the aims of the implementer.
    </p>
    <p>
        Still, while this can be an illuminating exercise, I don't pretend that this is truly black-box testing.
    </p>
    <h3 id="6c9dfbef5e974355802d4548b0d6e146">
        Pair programming <a href="#6c9dfbef5e974355802d4548b0d6e146">#</a>
    </h3>
    <p>
        If you pair-program, you have better options. You <em>could</em> have one person write a test, and another person implement the code to pass the test. I could imagine a setup where the tester can't see the production code. Although I've never seen or heard about anyone doing that, this would get close to true black-box TDD.
    </p>
    <p>
        To demonstrate, imagine a team doing the <a href="https://codingdojo.org/kata/FizzBuzz/">FizzBuzz kata</a> in this way. The tester writes the first test:
    </p>
    <p>
        <pre>[<span style="color:#2b91af;">Fact</span>]
<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">void</span>&nbsp;<span style="font-weight:bold;color:#74531f;">One</span>()
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">actual</span>&nbsp;=&nbsp;<span style="color:#2b91af;">FizzBuzzer</span>.<span style="color:#74531f;">Convert</span>(1);
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">Assert</span>.<span style="color:#74531f;">Equal</span>(<span style="color:#a31515;">&quot;1&quot;</span>,&nbsp;<span style="font-weight:bold;color:#1f377f;">actual</span>);
}</pre>
    </p>
    <p>
        Either the implementer is allowed to see the test, or the specification is communicated to him or her in some other way. In any case, the natural response to the first test is an implementation like this:
    </p>
    <p>
        <pre><span style="color:blue;">public</span>&nbsp;<span style="color:blue;">static</span>&nbsp;<span style="color:blue;">string</span>&nbsp;<span style="color:#74531f;">Convert</span>(<span style="color:blue;">int</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">number</span>)
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">return</span>&nbsp;<span style="color:#a31515;">&quot;1&quot;</span>;
}</pre>
    </p>
    <p>
        In TDD, this is expected. This is the simplest implementation that passes all tests. We imagine that the tester already knows this, and therefore adds this test next:
    </p>
    <p>
        <pre>[<span style="color:#2b91af;">Fact</span>]
<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">void</span>&nbsp;<span style="font-weight:bold;color:#74531f;">Two</span>()
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">actual</span>&nbsp;=&nbsp;<span style="color:#2b91af;">FizzBuzzer</span>.<span style="color:#74531f;">Convert</span>(2);
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">Assert</span>.<span style="color:#74531f;">Equal</span>(<span style="color:#a31515;">&quot;2&quot;</span>,&nbsp;<span style="font-weight:bold;color:#1f377f;">actual</span>);
}</pre>
    </p>
    <p>
        The implementer's response is this:
    </p>
    <p>
        <pre><span style="color:blue;">public</span>&nbsp;<span style="color:blue;">static</span>&nbsp;<span style="color:blue;">string</span>&nbsp;<span style="color:#74531f;">Convert</span>(<span style="color:blue;">int</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">number</span>)
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">if</span>&nbsp;(<span style="font-weight:bold;color:#1f377f;">number</span>&nbsp;==&nbsp;1)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">return</span>&nbsp;<span style="color:#a31515;">&quot;1&quot;</span>;
&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">return</span>&nbsp;<span style="color:#a31515;">&quot;2&quot;</span>;
}</pre>
    </p>
    <p>
        The tester can't see the implementation, so may believe that the implementation is now 'appropriate'. Even if he or she wants to be 'more sure', a few more test cases (for, say, <em>4</em>, <em>7</em>, or <em>38</em>) could be added; it doesn't make any difference for the following argument.
    </p>
    <p>
        Next, incrementally, the tester may add a few test cases that cover the <code>"Fizz"</code> behaviour:
    </p>
    <p>
        <pre>[<span style="color:#2b91af;">Fact</span>]
<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">void</span>&nbsp;<span style="font-weight:bold;color:#74531f;">Three</span>()
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">actual</span>&nbsp;=&nbsp;<span style="color:#2b91af;">FizzBuzzer</span>.<span style="color:#74531f;">Convert</span>(3);
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">Assert</span>.<span style="color:#74531f;">Equal</span>(<span style="color:#a31515;">&quot;Fizz&quot;</span>,&nbsp;<span style="font-weight:bold;color:#1f377f;">actual</span>);
}
 
[<span style="color:#2b91af;">Fact</span>]
<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">void</span>&nbsp;<span style="font-weight:bold;color:#74531f;">Six</span>()
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">actual</span>&nbsp;=&nbsp;<span style="color:#2b91af;">FizzBuzzer</span>.<span style="color:#74531f;">Convert</span>(6);
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">Assert</span>.<span style="color:#74531f;">Equal</span>(<span style="color:#a31515;">&quot;Fizz&quot;</span>,&nbsp;<span style="font-weight:bold;color:#1f377f;">actual</span>);
}</pre>
    </p>
    <p>
        Similar test cases cover the <code>"Buzz"</code> and <code>"FizzBuzz"</code> behaviours. For this example, I wrote eight test cases in total, but a more sceptical tester might write twelve or even sixteen before feeling confident that the test suite sufficiently describes the desired behaviour of the system. Even so, a sufficiently adversarial implementer might (given eight test cases) deliver this implementation:
    </p>
    <p>
        <pre><span style="color:blue;">public</span>&nbsp;<span style="color:blue;">static</span>&nbsp;<span style="color:blue;">string</span>&nbsp;<span style="color:#74531f;">Convert</span>(<span style="color:blue;">int</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">number</span>)
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">switch</span>&nbsp;(<span style="font-weight:bold;color:#1f377f;">number</span>)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">case</span>&nbsp;&nbsp;1:&nbsp;<span style="font-weight:bold;color:#8f08c4;">return</span>&nbsp;<span style="color:#a31515;">&quot;1&quot;</span>;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">case</span>&nbsp;&nbsp;2:&nbsp;<span style="font-weight:bold;color:#8f08c4;">return</span>&nbsp;<span style="color:#a31515;">&quot;2&quot;</span>;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">case</span>&nbsp;&nbsp;5:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">case</span>&nbsp;10:&nbsp;<span style="font-weight:bold;color:#8f08c4;">return</span>&nbsp;<span style="color:#a31515;">&quot;Buzz&quot;</span>;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">case</span>&nbsp;15:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">case</span>&nbsp;30:&nbsp;<span style="font-weight:bold;color:#8f08c4;">return</span>&nbsp;<span style="color:#a31515;">&quot;FizzBuzz&quot;</span>;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">default</span>:&nbsp;<span style="font-weight:bold;color:#8f08c4;">return</span>&nbsp;<span style="color:#a31515;">&quot;Fizz&quot;</span>;
&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre>
    </p>
    <p>
        To be clear, it's not that I expect real-world programmers to be either obtuse or nefarious. In real life, on the other hand, requirements are more complicated, and may be introduced piecemeal in a fashion that may lead to buggy, overly-complicated implementations.
    </p>
    <h3 id="8b7bb29424ea4c22a851aa98037cc43a">
        Under-determination <a href="#8b7bb29424ea4c22a851aa98037cc43a">#</a>
    </h3>
    <p>
        Remarkably, black-box testing may work better as an ex-post technique, compared to TDD. If we imagine that an implementer has made an effort to correctly implement a system according to specification, a tester may use black-box testing to poke at the SUT, using both randomly selected test cases, and by explicitly exercising the SUT at boundary cases.
    </p>
    <p>
        Even so, black-box testing in reality tends to run into the problem of <a href="https://en.wikipedia.org/wiki/Underdetermination">under-determination</a>, also known from philosophy of science. As I outlined in <a href="/2021/06/14/new-book-code-that-fits-in-your-head">Code That Fits in Your Head</a>, software testing has many similarities with empirical science. We use experiments (tests) to corroborate hypotheses that we have about software: Typically either that it <em>doesn't</em> pass tests, or that it does pass all tests, depending on where in the red-green-refactor cycle we are.
    </p>
    <p>
        Similar to science, we are faced with the basic epistemological problem that we have a finite number of tests, but usually an infinite (or at least extremely big) state space. Thus, as pointed out by the problem of under-determination, more than one 'reality' fits the available observations (i.e. test cases). The above FizzBuzz implementation is an example of this.
    </p>
    <p>
        As an aside, certain problems actually have <a href="https://en.wikipedia.org/wiki/Image_(mathematics)">images</a> that are sufficiently small that you <em>can</em> cover everything in total. In its most common description, the FizzBuzz kata, too, falls into this category.
    </p>
    <blockquote>
        <p>
            "Write a program that prints the numbers from <em>1 to 100</em>."
        </p>
        <footer><cite><a href="https://codingdojo.org/kata/FizzBuzz/">FizzBuzz</a></cite>, my emphasis</footer>
    </blockquote>
    <p>
        This means that you <em>can</em>, in fact, write 100 test cases and thereby specify the problem in its totality. What you still can't do with black-box testing, however, is impose a particular implementation. An adversarial implementer could write the <code>Convert</code> function as one big <code>switch</code> statement. Just like <a href="/2021/03/29/table-driven-tennis-scoring">I did with the Tennis kata</a>, another <a href="/2020/08/31/properties-for-all">kata with a small state space</a>.
    </p>
    <p>
        This, however, rarely happens in the real world. Example-driven testing is under-determined. And no, <a href="/2021/06/28/property-based-testing-is-not-the-same-as-partition-testing">property-based testing doesn't fundamentally change that conclusion</a>. It behoves you to <em>look</em> critically at the actual implementation code, and not rely exclusively on testing.
    </p>
    <h3 id="83a20a3021d94138b5cbdd8f1dd2f71a">
        Working with implementation code <a href="#83a20a3021d94138b5cbdd8f1dd2f71a">#</a>
    </h3>
    <p>
        It's hardly a surprise that TDD isn't black-box testing. Is it white-box testing, then? Since the red-green-refactor cycle dictates a tight loop between test and production code, you always have the implementation code at hand. In that sense, the SUT is a white box.
    </p>
    <p>
        That said, the <a href="https://en.wikipedia.org/wiki/White-box_testing">common view on white-box testing</a> is that you work with knowledge about the internal implementation of an <em>already-written</em> system, and use that to design test cases. Typically, looking at the code should enable a tester to identify weak spots that warrant testing.
    </p>
    <p>
        This isn't always the case with TDD. If you follow the red-green-refactor checklist, each cycle should leave you with a SUT that passes all tests in the simplest way that could possibly work. Consider the first incarnation of <code>Convert</code>, above (the one that always returns <code>"1"</code>). It passes all tests, and from a white-box-testing perspective, it has no weak spots. You can't identify a test case that'll make if crash.
    </p>
    <p>
        If you consider the test suite as an executable specification, that degenerate implementation is <em>correct</em>, since it passes all tests. Of course, according to the kata description, it's wrong. Looking at the SUT code will tell you that in a heartbeat. It should prompt you to add another test case. The question is, though, whether that qualifies as white-box testing, or it's rather reminiscent of the <a href="https://blog.cleancoder.com/uncle-bob/2013/05/27/TheTransformationPriorityPremise.html">transformation priority premise</a>. Not that that's necessarily a dichotomy.
    </p>
    <h3 id="d3c56178d31c4c1fb25654a4a5e48243">
        Overspecified software <a href="#d3c56178d31c4c1fb25654a4a5e48243">#</a>
    </h3>
    <p>
        Perhaps a more common problem with white-box testing in relation to TDD is the tendency to take a given implementation for granted. Of course, working according to the red-green-refactor cycle, there's no implementation before the test, but a common technique is to use <a href="http://xunitpatterns.com/Mock%20Object.html">Mock Objects</a> to let tests specify how the SUT should be implemented. This leads to the familiar problem of <a href="http://xunitpatterns.com/Fragile%20Test.html">Overspecified Software</a>.
    </p>
    <p>
        Here's an example.
    </p>
    <h3 id="a26fc9b04a5f440aac256c6f19db26a8">
        Finding values in an interval <a href="#a26fc9b04a5f440aac256c6f19db26a8">#</a>
    </h3>
    <p>
        In the code base that accompanies <a href="/code-that-fits-in-your-head">Code That Fits in Your Head</a>, the code that handles a new restaurant reservation contains this code snippet:
    </p>
    <p>
        <pre><span style="color:blue;">var</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">reservations</span>&nbsp;=&nbsp;<span style="font-weight:bold;color:#8f08c4;">await</span>&nbsp;Repository
&nbsp;&nbsp;&nbsp;&nbsp;.<span style="font-weight:bold;color:#74531f;">ReadReservations</span>(<span style="font-weight:bold;color:#1f377f;">restaurant</span>.Id,&nbsp;<span style="font-weight:bold;color:#1f377f;">reservation</span>.At)
&nbsp;&nbsp;&nbsp;&nbsp;.<span style="font-weight:bold;color:#74531f;">ConfigureAwait</span>(<span style="color:blue;">false</span>);
<span style="color:blue;">var</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">now</span>&nbsp;=&nbsp;Clock.<span style="font-weight:bold;color:#74531f;">GetCurrentDateTime</span>();
<span style="font-weight:bold;color:#8f08c4;">if</span>&nbsp;(!<span style="font-weight:bold;color:#1f377f;">restaurant</span>.MaitreD.<span style="font-weight:bold;color:#74531f;">WillAccept</span>(<span style="font-weight:bold;color:#1f377f;">now</span>,&nbsp;<span style="font-weight:bold;color:#1f377f;">reservations</span>,&nbsp;<span style="font-weight:bold;color:#1f377f;">reservation</span>))
&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">return</span>&nbsp;<span style="color:#74531f;">NoTables500InternalServerError</span>();
 
<span style="font-weight:bold;color:#8f08c4;">await</span>&nbsp;Repository.<span style="font-weight:bold;color:#74531f;">Create</span>(<span style="font-weight:bold;color:#1f377f;">restaurant</span>.Id,&nbsp;<span style="font-weight:bold;color:#1f377f;">reservation</span>)
&nbsp;&nbsp;&nbsp;&nbsp;.<span style="font-weight:bold;color:#74531f;">ConfigureAwait</span>(<span style="color:blue;">false</span>);</pre>
    </p>
    <p>
        The <code>ReadReservations</code> method is of particular interest in this context. It turns out to be a small extension method on a more general interface method:
    </p>
    <p>
        <pre><span style="color:blue;">internal</span>&nbsp;<span style="color:blue;">static</span>&nbsp;<span style="color:#2b91af;">Task</span>&lt;<span style="color:#2b91af;">IReadOnlyCollection</span>&lt;<span style="color:#2b91af;">Reservation</span>&gt;&gt;&nbsp;<span style="color:#74531f;">ReadReservations</span>(
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">this</span>&nbsp;<span style="color:#2b91af;">IReservationsRepository</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">repository</span>,
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">int</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">restaurantId</span>,
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">DateTime</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">date</span>)
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">min</span>&nbsp;=&nbsp;<span style="font-weight:bold;color:#1f377f;">date</span>.Date;
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">max</span>&nbsp;=&nbsp;<span style="font-weight:bold;color:#1f377f;">min</span>.<span style="font-weight:bold;color:#74531f;">AddDays</span>(1).<span style="font-weight:bold;color:#74531f;">AddTicks</span>(-1);
&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">return</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">repository</span>.<span style="font-weight:bold;color:#74531f;">ReadReservations</span>(<span style="font-weight:bold;color:#1f377f;">restaurantId</span>,&nbsp;<span style="font-weight:bold;color:#1f377f;">min</span>,&nbsp;<span style="font-weight:bold;color:#1f377f;">max</span>);
}</pre>
    </p>
    <p>
        The <code>IReservationsRepository</code> interface doesn't have a method that allows a client to search for all reservations on a given date. Rather, it defines a more general method that enables clients to search for reservations in a given interval:
    </p>
    <p>
        <pre><span style="color:#2b91af;">Task</span>&lt;<span style="color:#2b91af;">IReadOnlyCollection</span>&lt;<span style="color:#2b91af;">Reservation</span>&gt;&gt;&nbsp;<span style="font-weight:bold;color:#74531f;">ReadReservations</span>(
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">int</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">restaurantId</span>,&nbsp;<span style="color:#2b91af;">DateTime</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">min</span>,&nbsp;<span style="color:#2b91af;">DateTime</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">max</span>);</pre>
    </p>
    <p>
        As the parameter names imply, the method finds and returns all the reservations for a given restaurant between the <code>min</code> and <code>max</code> values. <a href="/2021/12/06/the-liskov-substitution-principle-as-a-profunctor">A previous article</a> already covers this method in much detail.
    </p>
    <p>
        I think I've stated this more than once before: Code is never perfect. Although I made a genuine attempt to write quality code for the book's examples, now that I revisit this API, I realize that there's room for improvement. The most obvious problem with that method definition is that it's not clear whether the range includes, or excludes, the boundary values. Would it improve encapsulation if the method instead took a <a href="/2024/01/22/a-range-kata-implementation-in-c">Range&lt;DateTime&gt;</a> parameter?
    </p>
    <p>
        At the very least, I could have named the parameters <code>inclusiveMin</code> and <code>inclusiveMax</code>. That's how the system is implemented, and you can see an artefact of that in the above extension method. It searches from midnight of <code>date</code> to the tick just before midnight on the next day.
    </p>
    <p>
        The SQL implementation reflects that contract, too.
    </p>
    <p>
        <pre><span style="color:blue;">SELECT</span>&nbsp;[PublicId]<span style="color:gray;">,</span>&nbsp;[At]<span style="color:gray;">,</span>&nbsp;[Name]<span style="color:gray;">,</span>&nbsp;[Email]<span style="color:gray;">,</span>&nbsp;[Quantity]
<span style="color:blue;">FROM</span>&nbsp;[dbo]<span style="color:gray;">.</span>[Reservations]
<span style="color:blue;">WHERE</span>&nbsp;[RestaurantId]&nbsp;<span style="color:gray;">=</span>&nbsp;@RestaurantId&nbsp;<span style="color:gray;">AND</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@Min&nbsp;<span style="color:gray;">&lt;=</span>&nbsp;[At]&nbsp;<span style="color:gray;">AND</span>&nbsp;[At]&nbsp;<span style="color:gray;">&lt;=</span>&nbsp;@Max</pre>
    </p>
    <p>
        Here, <code>@RestaurantId</code>, <code>@Min</code>, and <code>@Max</code> are query parameters. Notice that the query uses the <code>&lt;=</code> relation for both <code>@Min</code> and <code>@Max</code>, making both endpoints inclusive.
    </p>
    <h3 id="c3113935f001498681c7052959c30b2b">
        Interactive white-box testing <a href="#c3113935f001498681c7052959c30b2b">#</a>
    </h3>
    <p>
        Since I'm aware of the problem of overspecified software, I test-drove the entire code base using <a href="/2019/02/18/from-interaction-based-to-state-based-testing">state-based testing</a>. Imagine, however, that I'd instead used a dynamic mock library. If so, a test could have looked like this:
    </p>
    <p>
        <pre>[<span style="color:#2b91af;">Fact</span>]
<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">async</span>&nbsp;<span style="color:#2b91af;">Task</span>&nbsp;<span style="font-weight:bold;color:#74531f;">PostUsingMoq</span>()
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">now</span>&nbsp;=&nbsp;<span style="color:#2b91af;">DateTime</span>.Now;
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">reservation</span>&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">Some</span>.Reservation.<span style="font-weight:bold;color:#74531f;">WithDate</span>(<span style="font-weight:bold;color:#1f377f;">now</span>.<span style="font-weight:bold;color:#74531f;">AddDays</span>(2).<span style="font-weight:bold;color:#74531f;">At</span>(20,&nbsp;15));
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">repoTD</span>&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">Mock</span>&lt;<span style="color:#2b91af;">IReservationsRepository</span>&gt;();
&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#1f377f;">repoTD</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.<span style="font-weight:bold;color:#74531f;">Setup</span>(<span style="font-weight:bold;color:#1f377f;">r</span>&nbsp;=&gt;&nbsp;<span style="font-weight:bold;color:#1f377f;">r</span>.<span style="font-weight:bold;color:#74531f;">ReadReservations</span>(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">Some</span>.Restaurant.Id,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#1f377f;">reservation</span>.At.Date,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#1f377f;">reservation</span>.At.Date.<span style="font-weight:bold;color:#74531f;">AddDays</span>(1).<span style="font-weight:bold;color:#74531f;">AddTicks</span>(-1)))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.<span style="font-weight:bold;color:#74531f;">ReturnsAsync</span>(<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">Collection</span>&lt;<span style="color:#2b91af;">Reservation</span>&gt;());
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">sut</span>&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">ReservationsController</span>(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">SystemClock</span>(),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">InMemoryRestaurantDatabase</span>(<span style="color:#2b91af;">Some</span>.Restaurant),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#1f377f;">repoTD</span>.Object);
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">ar</span>&nbsp;=&nbsp;<span style="font-weight:bold;color:#8f08c4;">await</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">sut</span>.<span style="font-weight:bold;color:#74531f;">Post</span>(<span style="color:#2b91af;">Some</span>.Restaurant.Id,&nbsp;<span style="font-weight:bold;color:#1f377f;">reservation</span>.<span style="font-weight:bold;color:#74531f;">ToDto</span>());
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">Assert</span>.<span style="color:#74531f;">IsAssignableFrom</span>&lt;<span style="color:#2b91af;">CreatedAtActionResult</span>&gt;(<span style="font-weight:bold;color:#1f377f;">ar</span>);
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:green;">//&nbsp;More&nbsp;assertions&nbsp;could&nbsp;go&nbsp;here.</span>
}</pre>
    </p>
    <p>
        This test uses <a href="https://github.com/devlooped/moq">Moq</a>, but the example doesn't hinge on that. I rarely use dynamic mock libraries these days, but when I do, I still prefer Moq.
    </p>
    <p>
        Notice how the <code>Setup</code> reproduces the implementation of the <code>ReadReservations</code> extension method. The implication is that if you change the implementation code, you break the test.
    </p>
    <p>
        Even so, we may consider this an example of a test-driven white-box test. While, according to the red-green-refactor cycle, you're supposed to write the test before the implementation, this style of TDD only works if you, the test writer, has an exact plan for how the SUT is going to look.
    </p>
    <h3 id="7eda505b89c646c7a02b1726901b30b9">
        An innocent refactoring? <a href="#7eda505b89c646c7a02b1726901b30b9">#</a>
    </h3>
    <p>
        Don't you find that <code><span style="font-weight:bold;color:#1f377f;">min</span>.<span style="font-weight:bold;color:#74531f;">AddDays</span>(1).<span style="font-weight:bold;color:#74531f;">AddTicks</span>(-1)</code> expression a bit odd? Wouldn't the code be cleaner if you could avoid the <code><span style="font-weight:bold;color:#74531f;">AddTicks</span>(-1)</code> part?
    </p>
    <p>
        Well, you can.
    </p>
    <p>
        A <em>tick</em> is the smallest unit of measurement of <a href="https://learn.microsoft.com/dotnet/api/system.datetime">DateTime</a> values. Since ticks are discrete, the range defined by the extension method would be equivalent to a right-open interval, where the minimum value is still included, but the maximum is not. If you made that change, the extension method would be simpler:
    </p>
    <p>
        <pre><span style="color:blue;">internal</span>&nbsp;<span style="color:blue;">static</span>&nbsp;<span style="color:#2b91af;">Task</span>&lt;<span style="color:#2b91af;">IReadOnlyCollection</span>&lt;<span style="color:#2b91af;">Reservation</span>&gt;&gt;&nbsp;<span style="color:#74531f;">ReadReservations</span>(
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">this</span>&nbsp;<span style="color:#2b91af;">IReservationsRepository</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">repository</span>,
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">int</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">restaurantId</span>,
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">DateTime</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">date</span>)
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">min</span>&nbsp;=&nbsp;<span style="font-weight:bold;color:#1f377f;">date</span>.Date;
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">max</span>&nbsp;=&nbsp;<span style="font-weight:bold;color:#1f377f;">min</span>.<span style="font-weight:bold;color:#74531f;">AddDays</span>(1);
&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">return</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">repository</span>.<span style="font-weight:bold;color:#74531f;">ReadReservations</span>(<span style="font-weight:bold;color:#1f377f;">restaurantId</span>,&nbsp;<span style="font-weight:bold;color:#1f377f;">min</span>,&nbsp;<span style="font-weight:bold;color:#1f377f;">max</span>);
}</pre>
    </p>
    <p>
        In order to offset that change, you also change the SQL accordingly:
    </p>
    <p>
        <pre><span style="color:blue;">SELECT</span>&nbsp;[PublicId]<span style="color:gray;">,</span>&nbsp;[At]<span style="color:gray;">,</span>&nbsp;[Name]<span style="color:gray;">,</span>&nbsp;[Email]<span style="color:gray;">,</span>&nbsp;[Quantity]
<span style="color:blue;">FROM</span>&nbsp;[dbo]<span style="color:gray;">.</span>[Reservations]
<span style="color:blue;">WHERE</span>&nbsp;[RestaurantId]&nbsp;<span style="color:gray;">=</span>&nbsp;@RestaurantId&nbsp;<span style="color:gray;">AND</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@Min&nbsp;<span style="color:gray;">&lt;=</span>&nbsp;[At]&nbsp;<span style="color:gray;">AND</span>&nbsp;[At]&nbsp;<span style="color:gray;">&lt;</span>&nbsp;@Max</pre>
    </p>
    <p>
        Notice that the query now compares <code>[At]</code> with <code>@Max</code> using the <code>&lt;</code> relation.
    </p>
    <p>
        While this is formally a breaking change of the interface, it's entirely internal to the application code base. No external systems or libraries depend on <code>IReservationsRepository</code>. Thus, this change is a true refactoring: It improves the code without changing the observable behaviour of the system.
    </p>
    <p>
        Even so, this change breaks the <code>PostUsingMoq</code> test.
    </p>
    <p>
        To make the test pass, you'll need to repeat the change you made to the SUT:
    </p>
    <p>
        <pre>[<span style="color:#2b91af;">Fact</span>]
<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">async</span>&nbsp;<span style="color:#2b91af;">Task</span>&nbsp;<span style="font-weight:bold;color:#74531f;">PostUsingMoq</span>()
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">now</span>&nbsp;=&nbsp;<span style="color:#2b91af;">DateTime</span>.Now;
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">reservation</span>&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">Some</span>.Reservation.<span style="font-weight:bold;color:#74531f;">WithDate</span>(<span style="font-weight:bold;color:#1f377f;">now</span>.<span style="font-weight:bold;color:#74531f;">AddDays</span>(2).<span style="font-weight:bold;color:#74531f;">At</span>(20,&nbsp;15));
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">repoTD</span>&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">Mock</span>&lt;<span style="color:#2b91af;">IReservationsRepository</span>&gt;();
&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#1f377f;">repoTD</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.<span style="font-weight:bold;color:#74531f;">Setup</span>(<span style="font-weight:bold;color:#1f377f;">r</span>&nbsp;=&gt;&nbsp;<span style="font-weight:bold;color:#1f377f;">r</span>.<span style="font-weight:bold;color:#74531f;">ReadReservations</span>(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">Some</span>.Restaurant.Id,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#1f377f;">reservation</span>.At.Date,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#1f377f;">reservation</span>.At.Date.<span style="font-weight:bold;color:#74531f;">AddDays</span>(1)))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.<span style="font-weight:bold;color:#74531f;">ReturnsAsync</span>(<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">Collection</span>&lt;<span style="color:#2b91af;">Reservation</span>&gt;());
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">sut</span>&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">ReservationsController</span>(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">SystemClock</span>(),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">InMemoryRestaurantDatabase</span>(<span style="color:#2b91af;">Some</span>.Restaurant),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#1f377f;">repoTD</span>.Object);
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">ar</span>&nbsp;=&nbsp;<span style="font-weight:bold;color:#8f08c4;">await</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">sut</span>.<span style="font-weight:bold;color:#74531f;">Post</span>(<span style="color:#2b91af;">Some</span>.Restaurant.Id,&nbsp;<span style="font-weight:bold;color:#1f377f;">reservation</span>.<span style="font-weight:bold;color:#74531f;">ToDto</span>());
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">Assert</span>.<span style="color:#74531f;">IsAssignableFrom</span>&lt;<span style="color:#2b91af;">CreatedAtActionResult</span>&gt;(<span style="font-weight:bold;color:#1f377f;">ar</span>);
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:green;">//&nbsp;More&nbsp;assertions&nbsp;could&nbsp;go&nbsp;here.</span>
}</pre>
    </p>
    <p>
        If it's only one test, you can probably live with that, but it's the opposite of a robust test; it's a <a href="http://xunitpatterns.com/Fragile%20Test.html">Fragile Test</a>.
    </p>
    <blockquote>
        <p>
            "to refactor, the essential precondition is [...] solid tests"
        </p>
        <footer><cite><a href="/ref/refactoring">Refactoring</a>, Martin Fowler, 1999</cite></footer>
    </blockquote>
    <p>
        A common problem with <a href="/2019/02/25/an-example-of-interaction-based-testing-in-c">interaction-based testing</a> is that even small refactorings break many tests. We might see that as a symptom of having too much knowledge of implementation details. We might view this as related to white-box testing.
    </p>
    <p>
        To be clear, the tests in the code base that accompanies <a href="/code-that-fits-in-your-head">Code That Fits in Your Head</a> are all state-based, so contrary to the <code>PostUsingMoq</code> test, all 161 tests easily survive the above refactoring.
    </p>
    <h3 id="b41f2409e6de4ae9abfc95b7ec40da21">
        Greyscale-box TDD <a href="#b41f2409e6de4ae9abfc95b7ec40da21">#</a>
    </h3>
    <p>
        It's not too hard to argue that TDD isn't black-box testing, but it's harder to argue that it's not white-box testing. Naturally, as you follow the red-green-refactor cycle, you know all about the implementation. Still, the danger of being too aware of the SUT code is being trapped in an <a href="/2024/12/09/implementation-and-usage-mindsets">implementation mindset</a>.
    </p>
    <p>
        While there's nothing wrong with getting the implementation right, many maintainability problems originate in insufficient <a href="/encapsulation-and-solid">encapsulation</a>. Deliberately treating the SUT as a grey box helps in discovering a SUT's contract. That's why I recommend techniques like <a href="/2019/10/07/devils-advocate">Devil's Advocate</a>. Pretending to view the SUT from the outside can shed valuable light on usability and maintainability issues.
    </p>
    <h3 id="adbf81f39d8e44f7a56fc05623967245">
        Conclusion <a href="#adbf81f39d8e44f7a56fc05623967245">#</a>
    </h3>
    <p>
        The notions of white-box and black-box testing have been around for decades. So has TDD. Even so, it's not always clear to practitioners whether TDD is one or the other. The reason is, I believe, that TDD is neither. Good TDD practice sits somewhere between white-box testing and black-box testing.
    </p>
    <p>
        Exactly where on that greyscale spectrum TDD belongs depends on context. The more important encapsulation is, the closer you should move towards black-box testing. The more important correctness or algorithm performance is, the closer to white-box testing you should move.
    </p>
    <p>
        You can, however, move position on the spectrum even in the same code base. Perhaps you want to start close to white-box testing as you focus on getting the implementation right. Once the SUT works as intended, you may then decide to shift your focus towards encapsulation, in which case moving closer to black-box testing could prove beneficial.
    </p>
</div>