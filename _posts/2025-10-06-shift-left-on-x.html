---
layout: post
title: "Shift left on x"
description: "A difficult task may be easier if done sooner."
date: 2025-10-06 7:57 UTC
tags: [Productivity]
image: "/content/binary/stepwise-cost-increase-over-time.png"
image_alt: "Graph with time along the x-axis and cost on the y-axis. A staircase-shaped figure indicates a stepwise increasing function."
---
{% include JB/setup %}

<div id="post">
    <p>
        <em>{{ page.description }}</em>
    </p>
    <p>
        You've probably seen a figure like this before:
    </p>
    <p>
        <img src="/content/binary/continuous-cost-increse-over-time.png" alt="Graph with time along the x-axis and cost on the y-axis. One curve goes from low cost to high cost as time increases.">
    </p>
    <p>
        The point is that as time passes, the cost of doing something increases. This is often used to explain why test-driven development (TDD) or other agile methods are cost-effective alternatives to a waterfall process.
    </p>
    <p>
        Last time I checked, however, there was scant <a href="/2020/05/25/wheres-the-science">scientific evidence</a> for this curve.
    </p>
    <p>
        Even so, it <em>feels</em> right. If you discover a bug while you write the code, it's much easier to fix it than if it's discovered weeks later.
    </p>
    <h3 id="3f639ac506f548949c588767f3860ec3">
        Make security easier <a href="#3f639ac506f548949c588767f3860ec3">#</a>
    </h3>
    <p>
        I was recently reminded of the above curve because a customer of mine was struggling with security; mostly authentication and authorization. They asked me if there was a software-engineering practice that could help them get a better handle on security. Since this is a customer who's otherwise quite knowledgeable about agile methods and software engineering, I was a little surprised that they hadn't heard the phrase <em>shift left on security</em>.
    </p>
    <p>
        The idea fits with the above diagram. 'Shifting left' implies moving to the left on the time axis. In other words, do things sooner. Specifically related to security, the idea is to include security concerns early in every software development process.
    </p>
    <p>
        There's little new in this. <a href="/ref/writing-secure-code-2e">Writing Secure Code</a> from 2004 describes how <em>threat modelling</em> is part of secure coding practices. This is something I've had in the back of my mind since reading the book. I also describe the technique and give an example in <a href="/2021/06/14/new-book-code-that-fits-in-your-head">Code That Fits in Your Head</a>.
    </p>
    <p>
        If I know that a system I'm developing requires authentication, some of the first automated acceptance tests I write is one that successfully authenticates against the system, and one or more that fail to do so. Again, the code base that accompanies Code That Fits in Your Head has examples of this.
    </p>
    <p>
        Since my customer's question reminded me of this practice, I began pondering the idea of 'shifting left'. Since it's both touted as a benefit of TDD and DevSecOps, an obvious pattern suggests itself.
    </p>
    <h3 id="e23188bbc34f4a0099411bf059ed9d08">
        Sufficient requirements <a href="#e23188bbc34f4a0099411bf059ed9d08">#</a>
    </h3>
    <p>
        It's been years since I last drew the above diagram. As I implied, one problem with it is that there seems to be little quantifiable evidence for that relationship. On the other hand, you've surely had the experience that some tasks become harder, the longer you wait. I'll list some example later.
    </p>
    <p>
        While we may not have solid scientific evidence that a cost curve looks like above, it doesn't have to look like that to make shifting left worthwhile. All it takes, really, is that the relationship is non-decreasing, and increases at least once. It doesn't have to be polynomial or exponential; it may be linear or logarithmic. It may even be a non-decreasing <a href="https://en.wikipedia.org/wiki/Step_function">step function</a>, like this:
    </p>
    <p>
        <img src="/content/binary/stepwise-cost-increase-over-time.png" alt="Graph with time along the x-axis and cost on the y-axis. A staircase-shaped figure indicates a stepwise increasing function.">
    </p>
    <p>
        This, as far as I can tell, is a sufficient condition to warrant shifting left on an activity. If you have even <a href="https://martinfowler.com/bliki/AnecdotalEvidence.html">anecdotal evidence</a> that it may be more costly to postpone an activity, do it sooner. In practice, I don't think that you need to wait for solid scientific evidence before you do this.
    </p>
    <p>
        While not quite the same, it's a notion similar to the old agile saw: <em>If it hurts, do it more often.</em> Instead, we may phrase it as: <em>If it gets harder with time, do it sooner.</em>
    </p>
    <h3 id="fb9cd07bc9174af39d7dd1be92289408">
        Examples <a href="#fb9cd07bc9174af39d7dd1be92289408">#</a>
    </h3>
    <p>
        You've already seen two examples: TDD and security. Are there other examples where tackling problems sooner may decrease cost? Certainly.
    </p>
    <p>
        A few, I cover in <a href="/code-that-fits-in-your-head">Code That Fits in Your Head</a>. The earlier you automate the build process, the easier it is. The earlier you treat all warnings as errors, the easier it is. This seems almost self-explanatory, particularly when it comes to treating warnings as errors. In a brand-new code base, you have no warnings. In that situation, treating warnings as errors is free. When, later, a compiler warning appears, your code doesn't compile, and you're forced to immediately deal with it. At that time, it tends to be much easier to fix the issue, because no other code depends on the code with the warning.
    </p>
    <p>
        A similar situation applies to an automated build. At the beginning, an automated build is a simple batch file with one command. <code>dotnet test -c Release</code>, <code>stack test</code>, <code>py -m pytest</code>, and so on. Later, when you need to deal with databases, security, third-party components, etc. you enhance the automated build 'just in time'.
    </p>
    <p>
        Once you have an automated build, deployment is a small step further. In the beginning, deploying an application is typically as easy as copying some program files (compiled code or source files, depending on language) to the machines on which it's going to run. An exception may be if the deployment target is some sort of app store, with a vetting process that prevents you from deploying a walking skeleton. If, on the other hand, your organization controls the deployment target, the sooner you deploy a hello-world application, the easier it is.
    </p>
    <p>
        Yet another shift-left example is using static code analysis or <a href="https://en.wikipedia.org/wiki/Lint_(software)">linting</a>, particularly when combined with treating warnings as errors. Linters are usually free, and as I describe in Code That Fits in Your Head, I've always found it irrational that teams don't use them. Not that I don't understand the mechanism, because if you only turn them on at a time when the code base has already accumulated thousands of linter issues, the sheer volume is overwhelming.
    </p>
    <p>
        Closely related to this discussion is the <a href="/2023/01/23/agilean">lean development notion that bugs are stop-the-line issues</a>. The correct number of known bugs in the code base is zero. The correct number of unhandled exceptions in production is zero. This sounds unattainable to most people, but is possible if you shift left on managing defects.
    </p>
    <p>
        In short:
    </p>
    <ul>
        <li>Shift left on security</li>
        <li>Shift left on testing</li>
        <li>Shift left on treating warnings as errors</li>
        <li>Shift left on automated builds</li>
        <li>Shift left on deployment</li>
        <li>Shift left on linting</li>
        <li>Shift left on defect management</li>
    </ul>
    <p>
        This list is hardly exhaustive.
    </p>
    <h3 id="a20b501150c34db585453d9009f582db">
        Shift right <a href="#a20b501150c34db585453d9009f582db">#</a>
    </h3>
    <p>
        While it increases your productivity to do some things sooner, it's not a universal rule. Some things <a href="/2025/02/17/in-defence-of-multiple-wip">become easier, the longer you wait</a>. In terms of time-to-cost curves, this happens whenever the curve is decreasing, even if only step-wise.
    </p>
    <p>
        <img src="/content/binary/stepwise-cost-decrease-over-time.png" alt="Graph with time along the x-axis and cost on the y-axis. A staircase-shaped figure indicates a stepwise decreasing function.">
    </p>
    <p>
        The danger of these figures is that they may give the impression of a deterministic process. That need not be the case, but if you have reason to believe that waiting until later may make solving a problem easier, consider waiting. The notion of waiting until <a href="https://blog.codinghorror.com/the-last-responsible-moment/">the last responsible moment</a> is central to <a href="/2023/01/23/agilean">lean or agile software development</a>.
    </p>
    <p>
        In a sense, you could view this is 'shifting right' on certain tasks. More than once I've experienced that if you wait long enough with a certain task, it becomes irrelevant. Not just easier to perform, but something that you don't need to do at all. What looked like a requirement early on turned out to be not at all what the customer or user wanted, after all.
    </p>
    <h3 id="383b2c22a408406a91c17a11ed0bdbec">
        When to do what <a href="#383b2c22a408406a91c17a11ed0bdbec">#</a>
    </h3>
    <p>
        How do you distinguish? How do you decide if shifting left or shifting right is more appropriate? In practice, it's rarely difficult. The shift-left list above contains the usual suspects. While the list may not be exhaustive, it's a well-known list of practices that countless teams have found easier to do sooner rather than later.
    </p>
    <p>
        My own inclination would be to treat most other things as tasks that are better postponed. After all, you can't do <em>everything</em> as the <em>first</em> thing. Naturally, there has to be some sequencing of tasks.
    </p>
    <p>
        Thinking about such decisions in terms of time-cost curves feels natural to me. I find it an easy framework to consider whether I should shift left or right on some activity.
    </p>
    <h3 id="e5d50d3f31474bae91782e6623a48a8f">
        Conclusion <a href="#e5d50d3f31474bae91782e6623a48a8f">#</a>
    </h3>
    <p>
        Some things are easier if you get started as soon as possible. Candidates include testing, deployment, security, and defect management. This is the case when there's a increasing relationship between time and cost. This relationship need not be a quantified function. Often, you can get by with a sense that 'if I do this now, it's going to be easy; if I wait, it's going to be harder.'
    </p>
    <p>
        Conversely, some things are better postponed to the last responsible moment. This happens if the relation between time and cost is decreasing.
    </p>
    <p>
        Perhaps we can simplify this analysis even further. Perhaps you don't even need to think of (step) functions. All you may need is to consider the <a href="https://en.wikipedia.org/wiki/Partially_ordered_set">partial order</a> of tasks in terms of cost. Since I'm a visual thinker, however, increasing and decreasing functions come more naturally to me.
    </p>
</div>